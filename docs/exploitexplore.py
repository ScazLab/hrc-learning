import random

# returns the index of the max item in list. Randomly selects from max-indices if max appears multiple times
def rand_idx_max(lst):
	m = max(lst)
	l = [i for i, v in enumerate(lst) if v == m]
	return random.choice(l)

# Explore every possibility once until none are unexplored, then exploit
def explorefirst(options, trial, var):
	unexplored = [i for i, v in enumerate(options) if v == 0]
	nonneg     = [i for i, v in enumerate(options) if v >= 0]
	if unexplored:
		if var == 'A':
			return random.choice(nonneg) # return any random nonneg move
		else:							# var B or C. return one of unexplored
			return random.choice(unexplored)
	return rand_idx_max(options) # Exploit: pick (one of) the best

# Chooses an action using epsilon-greedy strategy, where e is some small probability of exploring instead of exploiting
def epsilongreedy(options, trial, var):
	e = .2
	r = random.random()
	if r > e:
		return rand_idx_max(options) # Exploit: pick (one of) the best
	else:
		unexplored = [i for i, v in enumerate(options) if v == 0]
		nonneg     = [i for i, v in enumerate(options) if v >= 0]
		if var == 'A':
			return random.choice(nonneg) # Explore: pick randomly
		if unexplored:
			return random.choice(unexplored)
		if var == 'B':
			return random.choice(nonneg) # Explore: pick randomly
		return rand_idx_max(options) # C

# In early trials, explore all the time, gradually diminishing to 10% explore.
def epsilondecreasing(options, trial, var):
	e = max(.1, (15-trial)/15) # 1, .9, .8, .7, .6, .5, .4, .3, .2, .1, .1, .1, .1, ...
	r = random.random()
	if r > e:
		return rand_idx_max(options) # Exploit: pick (one of) the best
	else:
		unexplored = [i for i, v in enumerate(options) if v == 0]
		nonneg     = [i for i, v in enumerate(options) if v >= 0]
		if var == 'A':
			return random.choice(nonneg) # Explore: pick randomly
		if unexplored:
			return random.choice(unexplored)
		if var == 'B':
			return random.choice(nonneg) # Explore: pick randomly
		return rand_idx_max(options) # C

# Likelihood of exploiting best option is proportional to quality of best option found.
# Quirky because any option with value > 10 will always be exploited. Arbitrary threshold. (potential issue with heavy backprop reinforcing a mediocre option and shutting out a better one. Happened to perform well for this setup, but must be tweaked for others)
def epsilonproportional(options, trial, var):
	m = max(options)
	e = (10-m)/10 # chance of exploring
	r = random.random()
	if r > e:
		return rand_idx_max(options) # Exploit: pick (one of) the best
	else:
		unexplored = [i for i, v in enumerate(options) if v == 0]
		nonneg     = [i for i, v in enumerate(options) if v >= 0]
		if var == 'A':
			return random.choice(nonneg) # Explore: pick randomly
		if unexplored:
			return random.choice(unexplored)
		if var == 'B':
			return random.choice(nonneg) # Explore: pick randomly
		return rand_idx_max(options) # C